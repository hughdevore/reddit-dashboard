{"version":3,"sources":["components/Article/style.js","components/Article/Article.js","App.js","serviceWorker.js","index.js"],"names":["Breadcrumb","Styled","div","Ups","span","Delete","Deleted","Title","h1","ArticleContent","backgroundColor","borderRadius","padding","color","ArticleContentLayout","whiteSpace","ArticleFooter","paddingTop","CommentContent","listStyleType","ChildCommentContent","paddingLeft","borderLeft","InfoPoints","InfoTime","Content","Layout","Footer","Header","Article","state","commentRoot","comment","body","author","created_utc","ups","nestedIndex","secondNestedParentIndex","lastNestedParentIndex","id","parent_id","this","rootIndex","findIndex","updateDeletedComment","forEach","children","setState","style","display","moment","unix","fromNow","key","onClick","deleteComment","icon","faTrashAlt","textDecoration","href","comments","props","article","builtCommentRoot","length","filter","parentIndex","push","child","nestedChildren","nestedParentIndex","lastNestedChildren","selftext","subreddit","title","commentsLength","faCommentAlt","width","map","nestedComments","nestedChildrenComments","lastNestedChildrenComments","renderCommentAuthor","datetime","renderCommentInfoContent","content","loading","isLoading","Component","App","fetch","response","json","fetchArticle","then","setTimeout","catch","err","console","log","boxShadow","fontFamily","active","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.b9c316b9.chunk.js","sourcesContent":["import Styled from 'styled-components';\n\nexport const Breadcrumb = Styled.div`\n  color: rgb(109.0, 109.0, 109.0);\n  letter-spacing: 1px;\n`;\n\nexport const Ups = Styled.span`\n  display: inline-block;\n  margin-right: 2em;\n`;\n\nexport const Delete = Styled.span`\n  display: inline-block;\n  margin-left: 1em;\n  font-size: 1em;\n  cursor: pointer;\n`;\n\nexport const Deleted = Styled.span`\n  display: inline-block;\n  margin-left: 1em;\n  font-size: 1em;\n`;\n\nexport const Title = Styled.h1`\n  display: inline-block;\n  font-size: 2em;\n  font-weight: 500;\n  margin: 20px 0;\n  color: rgb(44.0, 44.0, 44.0);\n`;\n\nexport const ArticleContent = {\n  backgroundColor: 'white',\n  borderRadius: '15px',\n  padding: '2em',\n  color: 'rgb(98, 98, 98)'\n}\n\nexport const ArticleContentLayout = {\n  backgroundColor: 'rgb(241.0, 241.0, 241.0)',\n  borderRadius: '15px',\n  padding: '2em 4em',\n  whiteSpace: 'pre-line'\n}\n\nexport const ArticleFooter = {\n  paddingTop: '1em'\n}\n\nexport const CommentContent = {\n  padding: '1em',\n  listStyleType: 'none'\n}\n\nexport const ChildCommentContent = {\n  padding: '1em',\n  paddingLeft: '4em',\n  borderLeft: '2px solid rgb(239, 239, 239)',\n  listStyleType: 'none'\n}\n\nexport const InfoPoints = Styled.span`\n  display: inline-block;\n  padding: 0 0 .5em 0;\n`;\n\nexport const InfoTime = Styled.span`\n  display: inline-block;\n  padding: 0 0 .5em 0;\n`;","import React, { Component, Fragment } from 'react';\nimport moment from 'moment';\nimport { Comment, Layout, PageHeader, Skeleton } from 'antd';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faCommentAlt, faTrashAlt } from '@fortawesome/free-solid-svg-icons';\n\nimport {\n  Breadcrumb,\n  Ups,\n  Delete,\n  Deleted,\n  Title,\n  ArticleContent,\n  ArticleContentLayout,\n  ArticleFooter,\n  CommentContent,\n  ChildCommentContent,\n  InfoPoints,\n  InfoTime\n} from './style';\n\nconst { Content, Footer, Header } = Layout;\n\nclass Article extends Component {\n  state = {\n    commentRoot: []\n  }\n\n  updateDeletedComment(comment) {\n    comment.body = 'This comment has been deleted.';\n    comment.author = 'N/A';\n    comment.created_utc = false;\n    comment.ups = 0;\n    return comment;\n  }\n\n  deleteComment(comment) {\n    const { id, parent_id } = comment;\n    const { commentRoot } = this.state;\n    let rootIndex = commentRoot.findIndex(comment => comment.id === id);\n    // Handle deleting comments on the root level.\n    if (!parent_id) {\n      commentRoot[rootIndex] = this.updateDeletedComment(comment);\n    }\n    // Get the index of the comment and update the body content.\n    let nestedIndex;\n    let secondNestedParentIndex;\n    let lastNestedParentIndex;\n    // Loop through all of the comments and delete the one matching the id that was clicked.\n    if (parent_id && rootIndex === -1 && commentRoot) {\n      commentRoot.forEach(comment => {\n        nestedIndex = comment.children ? comment.children.findIndex(comment => comment.id === id) : false;\n        if (typeof nestedIndex === \"number\" && nestedIndex !== -1) {\n          comment.children[nestedIndex] = this.updateDeletedComment(comment.children[nestedIndex]);\n        }\n        if (nestedIndex === -1 && comment.children) {\n          comment.children.forEach(comment => {\n            secondNestedParentIndex = comment.children ? comment.children.findIndex(comment => comment.id === id) : -1;\n            if (typeof secondNestedParentIndex === \"number\" && secondNestedParentIndex !== -1) {\n              comment.children[secondNestedParentIndex] = this.updateDeletedComment(comment.children[secondNestedParentIndex]);\n            }\n            if (secondNestedParentIndex === -1 &&  comment.children) {\n              comment.children.forEach(comment => {\n                lastNestedParentIndex = comment.children ? comment.children.findIndex(comment => comment.id === id) : -1;\n                if (typeof lastNestedParentIndex === \"number\" && lastNestedParentIndex !== -1) {\n                  comment.children[lastNestedParentIndex] = this.updateDeletedComment(comment.children[lastNestedParentIndex]);\n                }\n              });\n            }\n          });\n        }\n      });\n    }\n    this.setState({commentRoot});\n  }\n\n  renderCommentInfoContent(comment) {\n    const { created_utc, ups = 0 } = comment;\n    return (\n      <div style={{paddingLeft: '1em', display: 'inline-block', color: 'rgb(36, 36, 36)'}}>\n        <InfoPoints>{1 === ups ? ups+' point' : ups+' points'}</InfoPoints>\n        <span style={{padding: '0 .5em'}}>-</span>\n        <InfoTime>{created_utc ? moment.unix(created_utc).fromNow() : 'Deleted'}</InfoTime>\n          {created_utc ? \n            <Delete key={comment.id} onClick={() => this.deleteComment(comment)}>\n              <span key={comment.id}><FontAwesomeIcon icon={faTrashAlt} /></span>\n            </Delete>\n            :\n            <Deleted key={comment.id}>\n              <span key={comment.id}><FontAwesomeIcon icon={faTrashAlt} /></span>\n            </Deleted>\n          }\n      </div>\n    )\n  }\n\n  renderCommentAuthor(author) {\n    return (\n      <a style={{textDecoration: 'none'}} href={'https://www.reddit.com/user/' + author}>{author}</a>\n    );\n  }\n\n  componentDidMount() {\n    const { comments } = this.props.article;\n    const builtCommentRoot = [];\n    if ( comments && comments.length ) {\n      comments.forEach(comment => {        \n        const { parent_id } = comment;\n        // Get the children and dedupe.\n        let children = comments.filter(comment => comment.parent_id === parent_id);\n        let parentIndex = builtCommentRoot.findIndex(comment => comment.id === parent_id);\n        // If the comment doesn't have the 'parent_id' field add it the top level of commentMap.\n        if (!parent_id) return builtCommentRoot.push(comment);\n        if (builtCommentRoot[parentIndex] && children) {\n          // Add the children to the root comments.\n          if(!builtCommentRoot[parentIndex].children) {\n            builtCommentRoot[parentIndex].children = children;\n          } else if (builtCommentRoot[parentIndex].children) {\n            builtCommentRoot[parentIndex].children.push(children);\n          }\n          // Loop through the children and get their children.\n          children.forEach(child  => {\n            const { id } = child;\n            // Get the children of this child and dedupe.\n            let nestedChildren = comments.filter(comment => comment.parent_id === id);\n            // Get the index of this child.\n            let nestedParentIndex = builtCommentRoot[parentIndex].children.findIndex(child => child.id === id);\n            if (builtCommentRoot[parentIndex].children[nestedParentIndex] && nestedChildren) {\n              // Add the nestedChildren to the child.\n              if(!builtCommentRoot[parentIndex].children[nestedParentIndex].children) {\n                builtCommentRoot[parentIndex].children[nestedParentIndex].children = nestedChildren;\n              } else if (builtCommentRoot[parentIndex].children[nestedParentIndex].children) {\n                builtCommentRoot[parentIndex].children[nestedParentIndex].children.push(nestedChildren);\n              }\n              // Loop through the children and get their children.\n              nestedChildren.forEach(comment  => {\n                const { id } = comment;\n                //console.log(comment);\n                // Get the children of this child and dedupe.\n                let lastNestedChildren = comments.filter(comment => comment.parent_id === id);\n                // Get the index of this child.\n                let lastNestedParentIndex = builtCommentRoot[parentIndex].children[nestedParentIndex].children.findIndex(child => child.id === id);\n                if (builtCommentRoot[parentIndex].children[nestedParentIndex].children[lastNestedParentIndex] && lastNestedChildren) {\n                  // Add the lastNestedChildren to the child.\n                  if(!builtCommentRoot[parentIndex].children[nestedParentIndex].children[lastNestedParentIndex].children) {\n                    builtCommentRoot[parentIndex].children[nestedParentIndex].children[lastNestedParentIndex].children = lastNestedChildren;\n                  } else if (builtCommentRoot[parentIndex].children[nestedParentIndex].children[lastNestedParentIndex].children) {\n                    builtCommentRoot[parentIndex].children[nestedParentIndex].children[lastNestedParentIndex].children.push(lastNestedChildren);\n                  }\n                }\n              });\n            }\n          });\n        }\n      });\n      this.setState({commentRoot: builtCommentRoot});\n    }\n  }\n\n  render() {\n    const { comments, selftext, subreddit, title, ups } = this.props.article;\n    const commentsLength = comments ? comments.length : 0;\n    const { commentRoot } = this.state;\n    return (\n      <Fragment>\n        <Layout>\n          <Header>\n            <PageHeader>\n              <Breadcrumb>r/{subreddit}</Breadcrumb>\n              <Fragment>\n                <Ups>{ups/1000}k</Ups>\n                <Title>{title}</Title>\n              </Fragment>\n            </PageHeader>\n          </Header>\n          <Content style={ArticleContent}>\n            <Layout style={ArticleContentLayout}>\n              <Content >\n                {selftext}\n              </Content>\n              <Footer style={ArticleFooter}>\n                <FontAwesomeIcon icon={faCommentAlt} style={{padding: '0 .75em 0 0', width: '2em'}}/>\n                {comments ? commentsLength : 0} Comments\n              </Footer>\n            </Layout>\n            <Layout style={{paddingTop: '2em', display: 'inline-block'}}>\n              <Content>\n                {commentRoot && commentRoot.length ? commentRoot.map(comment => {\n                  const { author, body, children, id } = comment;\n                  const nestedComments = (children || []).map(comment => {\n                    const { author, body, children, id } = comment;   \n                    const nestedChildrenComments = (children || []).map(comment => {\n                      const { author, body, children, id } = comment;\n                      const lastNestedChildrenComments = (children || []).map(comment => {\n                        const { author, body, id } = comment;\n                        if (!id) return false;\n                        return (\n                          <Comment \n                            key={id}\n                            author={this.renderCommentAuthor(author !== '[deleted]' ? author : 'N/A')}\n                            datetime={this.renderCommentInfoContent(comment)}\n                            content={<span style={{padding: '.5em 0 1em 0', display: 'inline-block'}}>{body !== '[deleted]' ? body : 'This comment has been deleted.'}</span>}\n                            style={ChildCommentContent}\n                          />\n                        );\n                      });\n                      if (!id) return false;\n                      return (\n                        <Comment \n                          key={id}\n                          author={this.renderCommentAuthor(author !== '[deleted]' ? author : 'N/A')}\n                          datetime={this.renderCommentInfoContent(comment)}\n                          content={<span style={{padding: '.5em 0 1em 0', display: 'inline-block'}}>{body !== '[deleted]' ? body : 'This comment has been deleted.'}</span>}\n                          style={ChildCommentContent}\n                        >\n                          {lastNestedChildrenComments}\n                        </Comment>\n                      );\n                    });\n                    if (!id) return false;\n                    return (\n                      <Fragment key={id}>\n                        <Comment \n                          key={id}\n                          author={this.renderCommentAuthor(author !== '[deleted]' ? author : 'N/A')}\n                          datetime={this.renderCommentInfoContent(comment)}\n                          content={<span style={{padding: '.5em 0 1em 0', display: 'inline-block'}}>{body !== '[deleted]' ? body : 'This comment has been deleted.'}</span>}\n                          style={ChildCommentContent}\n                        >\n                          {nestedChildrenComments}\n                        </Comment>\n                      </Fragment>\n                    );\n                  });\n                  if (!id) return false;\n                  return (\n                    <Fragment key={id}>\n                      <Comment \n                        key={id}\n                        author={this.renderCommentAuthor(author !== '[deleted]' ? author : 'N/A')}\n                        datetime={this.renderCommentInfoContent(comment)}\n                        content={<span style={{padding: '.5em 0 1em 0', display: 'inline-block'}}>{body !== '[deleted]' ? body : 'This comment has been deleted.'}</span>}\n                        style={CommentContent}\n                      >\n                        {nestedComments}\n                      </Comment>\n                    </Fragment>\n                  );\n                }) : \n                  <Skeleton loading={this.props.isLoading} />\n                }\n              </Content>\n            </Layout>\n          </Content>\n        </Layout>\n      </Fragment>\n      \n    );\n  }\n}\n\n\nexport default Article;","import React, { Component, Fragment } from 'react';\nimport { Layout, Skeleton } from 'antd';\nimport 'antd/lib/skeleton/style/css';\nimport Article from './components/Article/Article';\n\nclass App extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      article: {},\n      isLoading: false,\n    };\n  }\n\n  async fetchArticle() {\n    let response = await fetch('https://gist.githubusercontent.com/mkg0/6a4dca9067ad7a296204e7c9ecd977b0/raw/0b1ec16580ea1e970a73f5c85563c22631be7ad7/unpopularopinion-dataset.json');\n    return response.json();\n  }\n\n  componentDidMount() {\n    this.setState({ isLoading: true });\n  \n    // Fetch the data for the article and comments.\n    this.fetchArticle()\n    .then(article => {\n      setTimeout( () => {\n        this.setState({ article, isLoading: false })\n      }, 750 );\n\n    })\n    .catch(err => {\n      console.log(err);\n    });\n\n  }\n\n  render() {\n    const { article, isLoading } = this.state;\n    return (\n      <Fragment>\n        <Layout\n          style={{\n            backgroundColor: 'rgb(222, 228, 234)',\n            padding: '7em 10em',\n          }}\n        >\n          <Layout\n            style={{\n              backgroundColor: 'rgb(249, 249, 249)',\n              padding: '3em 6em',\n              borderRadius: '15px',\n              boxShadow: '0 0 10px gray',\n              fontFamily: 'verdana'\n            }}\n          >\n            <Skeleton active={true} loading={isLoading}>\n              <Article article={article} />\n            </Skeleton>\n          </Layout>\n        </Layout>\n      </Fragment>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n/**\n * Don't register the service worker for this app yet since\n * it's still in development.\n */\nserviceWorker.unregister();\n"],"sourceRoot":""}